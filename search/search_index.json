{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Space Invader Projet du second semetre de : L\u00e9opold Cl\u00e9ment Thomas Omarini Si vous avez des difficult\u00e9s avec le jeu, un tutoriel est disponible ici . Sinon, tous les d\u00e9tails techniques sont expliquer ici . Si vous arriv\u00e9 jusqu'\u00e0 la vague 15, pr\u00e9venez nous.","title":"Home"},{"location":"#space-invader","text":"Projet du second semetre de : L\u00e9opold Cl\u00e9ment Thomas Omarini Si vous avez des difficult\u00e9s avec le jeu, un tutoriel est disponible ici . Sinon, tous les d\u00e9tails techniques sont expliquer ici . Si vous arriv\u00e9 jusqu'\u00e0 la vague 15, pr\u00e9venez nous.","title":"Space Invader"},{"location":"archi/","text":"Architecture du programme Le programe comporte plusieurs composants. Il y a : des threads des queues, pour comuniquer entre les threads, des varriables partag\u00e9es (type black board), un mutex, pour g\u00e9rer l'acces \u00e0 l'\u00e9cran des classes des p\u00e9rrif\u00e9rique: L' \u00e9cran Le g\u00e9n\u00e9rateur de nombre al\u00e9atoire Les leds Le joystick Diagramme des composants : Les composants int\u00e9ragicent de la mani\u00e8re suivante : Principales variables : Les principales variables sont : joueur qui repr\u00e9sente l'entier joueur et contient toutes les informations n\u00e9c\u00e9ssaires, Table_ennemis qui contient tous les monstres ainsi que leurs informations.","title":"Architecture du code"},{"location":"archi/#architecture-du-programme","text":"Le programe comporte plusieurs composants. Il y a : des threads des queues, pour comuniquer entre les threads, des varriables partag\u00e9es (type black board), un mutex, pour g\u00e9rer l'acces \u00e0 l'\u00e9cran des classes des p\u00e9rrif\u00e9rique: L' \u00e9cran Le g\u00e9n\u00e9rateur de nombre al\u00e9atoire Les leds Le joystick","title":"Architecture du programme"},{"location":"archi/#diagramme-des-composants","text":"Les composants int\u00e9ragicent de la mani\u00e8re suivante :","title":"Diagramme des composants :"},{"location":"archi/#principales-variables","text":"Les principales variables sont : joueur qui repr\u00e9sente l'entier joueur et contient toutes les informations n\u00e9c\u00e9ssaires, Table_ennemis qui contient tous les monstres ainsi que leurs informations.","title":"Principales variables :"},{"location":"class/","text":"Classe Les classes utilis\u00e9es sont les suivantes : Classe de representation Pour representer les \u00e9lements dans le jeu, on utilise les classes : Joueur qui n'est instancier qu'une seule fois, et qui represente le joueur, Monster qui represente les monstres, Missile qui represente les projectiles. Des instances de la classe Missile sont memebres des deux autres classes car elles representent les projeciles de basse. De plus, les threads Joueur_1 et Block_Enemie envoie des objet Missile dans la queue_N vers le thread Projectile pour lui signaler les nouveaux missiles \u00e0 simuler. Classe de messagerie Les classes utiles pour les messages sont struct Collision qui peremt de transmetre toutes les informations relatives \u00e0 un choc avec un monstre en m\u00eame temps, et la class enum End_Type qui d\u00e9crit le type de fin de vague que l'on rencontre (d\u00e9faite des monstre ou du joueur).","title":"Classe"},{"location":"class/#classe","text":"Les classes utilis\u00e9es sont les suivantes :","title":"Classe"},{"location":"class/#classe-de-representation","text":"Pour representer les \u00e9lements dans le jeu, on utilise les classes : Joueur qui n'est instancier qu'une seule fois, et qui represente le joueur, Monster qui represente les monstres, Missile qui represente les projectiles. Des instances de la classe Missile sont memebres des deux autres classes car elles representent les projeciles de basse. De plus, les threads Joueur_1 et Block_Enemie envoie des objet Missile dans la queue_N vers le thread Projectile pour lui signaler les nouveaux missiles \u00e0 simuler.","title":"Classe de representation"},{"location":"class/#classe-de-messagerie","text":"Les classes utiles pour les messages sont struct Collision qui peremt de transmetre toutes les informations relatives \u00e0 un choc avec un monstre en m\u00eame temps, et la class enum End_Type qui d\u00e9crit le type de fin de vague que l'on rencontre (d\u00e9faite des monstre ou du joueur).","title":"Classe de messagerie"},{"location":"joystick/","text":"Joystick On r\u00e9aliste un seuillage autour de la valeur centrale. Le joystick n'est pas vraiment annalogique, il n'y a que 8 directions possibles.","title":"Joystick"},{"location":"joystick/#joystick","text":"On r\u00e9aliste un seuillage autour de la valeur centrale. Le joystick n'est pas vraiment annalogique, il n'y a que 8 directions possibles.","title":"Joystick"},{"location":"lcd/","text":"L'\u00e9cran Organisation de l'\u00e9cran Les dix pixel en haut de l'\u00e9cran sont reserv\u00e9s pour l'affichage des informations. Les monstres sont rang\u00e9s sur trois rangs Mutex Pour ne pas aoir de probl\u00e8me d'interruption entre les threads pendant la manipulation de la m\u00e9moire de l'\u00e9cran, on utilise un mutex ainsi que une s\u00e9rie de fonction permetant de faire automatiquement l'attente et le relachement du mutex. Bitmap","title":"Ecran"},{"location":"lcd/#lecran","text":"","title":"L'\u00e9cran"},{"location":"lcd/#organisation-de-lecran","text":"Les dix pixel en haut de l'\u00e9cran sont reserv\u00e9s pour l'affichage des informations. Les monstres sont rang\u00e9s sur trois rangs","title":"Organisation de l'\u00e9cran"},{"location":"lcd/#mutex","text":"Pour ne pas aoir de probl\u00e8me d'interruption entre les threads pendant la manipulation de la m\u00e9moire de l'\u00e9cran, on utilise un mutex ainsi que une s\u00e9rie de fonction permetant de faire automatiquement l'attente et le relachement du mutex.","title":"Mutex"},{"location":"lcd/#bitmap","text":"","title":"Bitmap"},{"location":"led/","text":"LED et GPIO Ecriture sur les LEDs Pour facilit\u00e9 l'utilisation des LEDs, on utilise une liste d'objet struct led , ainsi Leds[n] = {{LEDXX_GPIO_Port, LEDXX_Pin}} . On peut ainsi utilis\u00e9 la ligne HAL_GPIO_WritePin(Leds[idx].port, Leds[idx].pin, !(charge-1<idx)); ce qui simplifit l'it\u00e9ration sur toutes les leds. Lecture sur les boutons On lis aussi l'\u00e9tat des bouton BP1 et BP2 via les GPIO.","title":"Leds"},{"location":"led/#led-et-gpio","text":"","title":"LED et GPIO"},{"location":"led/#ecriture-sur-les-leds","text":"Pour facilit\u00e9 l'utilisation des LEDs, on utilise une liste d'objet struct led , ainsi Leds[n] = {{LEDXX_GPIO_Port, LEDXX_Pin}} . On peut ainsi utilis\u00e9 la ligne HAL_GPIO_WritePin(Leds[idx].port, Leds[idx].pin, !(charge-1<idx)); ce qui simplifit l'it\u00e9ration sur toutes les leds.","title":"Ecriture sur les LEDs"},{"location":"led/#lecture-sur-les-boutons","text":"On lis aussi l'\u00e9tat des bouton BP1 et BP2 via les GPIO.","title":"Lecture sur les boutons"},{"location":"rng/","text":"G\u00e9nerateur de nombre al\u00e9atoire Utilisation du p\u00e9rriph\u00e9rique : On utilise le code suivant, car il n'y a pas toujours de nouveau nombre al\u00e9atoire disponible dans le buffer. uint32_t nombre_aleatoire; while (HAL_RNG_GenerateRandomNumber(&hrng, &nombre_aleatoire) != HAL_OK) ; Fonctions utilitaires On d\u00e9finit deux fonctions pour la suite : uint8_t proba_bernoulli(uint32_t numerateur, uint32_t denominateur) qui revoit 1 avec une probabilit\u00e9 de \\(\\frac{\\text{numerateur}}{\\text{denominateur}}\\) , 0 sinon, uint8_t proba_tirrage(uint8_t nombre_valeur) qui renvoit une nombre entre \\(1\\) et \\(\\text{nombre_valeur}\\) avec une probabilit\u00e9 uniforme, utile pour tirer un objet au hasard dans un liste.","title":"Al\u00e9atoire"},{"location":"rng/#generateur-de-nombre-aleatoire","text":"","title":"G\u00e9nerateur de nombre al\u00e9atoire"},{"location":"rng/#utilisation-du-perripherique","text":"On utilise le code suivant, car il n'y a pas toujours de nouveau nombre al\u00e9atoire disponible dans le buffer. uint32_t nombre_aleatoire; while (HAL_RNG_GenerateRandomNumber(&hrng, &nombre_aleatoire) != HAL_OK) ;","title":"Utilisation du p\u00e9rriph\u00e9rique :"},{"location":"rng/#fonctions-utilitaires","text":"On d\u00e9finit deux fonctions pour la suite : uint8_t proba_bernoulli(uint32_t numerateur, uint32_t denominateur) qui revoit 1 avec une probabilit\u00e9 de \\(\\frac{\\text{numerateur}}{\\text{denominateur}}\\) , 0 sinon, uint8_t proba_tirrage(uint8_t nombre_valeur) qui renvoit une nombre entre \\(1\\) et \\(\\text{nombre_valeur}\\) avec une probabilit\u00e9 uniforme, utile pour tirer un objet au hasard dans un liste.","title":"Fonctions utilitaires"},{"location":"thread/","text":"Les threads Description des threads : GameMaster Ce thread permet de g\u00e9rer la fin des niveaux, c\u00e0d que faire lorsque il n'y a plus de mostres ou plus de vie pour le joueur. Le thread est bloqu\u00e9 tant qu'il ne ressoit pas de message par queue_F . Ce thread est le plus important, car sans ses acions, le jeu ne peut pas avancer, il a donc la plus grande priorit\u00e9 Joueur_1 Ce tread g\u00e8re les d\u00e9placements et l'affichage du joueur ainsi que ses tirs. Ce thread est important \u00e0 la fluidit\u00e9 du jeu, il \u00e0 donc la deuxi\u00e8me plus grande priorit\u00e9 Block_Enemie Ce thread g\u00e8re le block d'ennemis, leurs vies, et leurs tirs. Pour chaque pas de temps, chaque monstre \u00e0 une probabilit\u00e9 de tirer de \\(\\frac{\\text{num\u00e9ro de la vague}}{15}\\) . Ainsi, \u00e0 chaque vague le jeu deviens plus dur. Ce thread a une priorit\u00e9 normale. Projectile Ce thread g\u00e8re les missiles. Il recois les demandes les nouveaux missiles par la queue_N , et si il n'y a pas trop de missiles d\u00e9j\u00e0 en jeu (moins de \\(200\\) ), il le rajoute et commence \u00e0 le simuler. C'est ce thread qui g\u00e8re toutes les collisions. En cas de collisions d\u00e9tecter, il tue le missile incrimin\u00e9 et envoie un messega via la queue_J quand le choc est avec le joueur, et la queue_E lorsque le choc implique un monstre. Ce thread a une priorit\u00e9 normale. HUD Ce thread g\u00e8re l'affichage de la bar d'info en haut de l'\u00e9cran, il ne fait que lire des varriables partag\u00e9. Ce thread a une priorit\u00e9 basse. chargeur Ce thread sert a incr\u00e9menter r\u00e9gulierement le compteur representant la charge du tir secondaire. Ce thread a une priorit\u00e9 basse. Communication entre les threads : Queue_F On envoie un objet enum End_Type , cela permet de d\u00e9bloqu\u00e9 le thread GameMaster . Queue_N On envoie un objet struct Missile , cela permet de demander la cr\u00e9ation d'un nouveau missile. Queue_J On envoie un int8_t qui represente les d\u00e9gats a appliquer au joueur (on peut imaginer des d\u00e9gats n\u00e9gatif pour des soins). Queue_E On envoie un objet struct collision qui comporte le num\u00e9ro du monstre et les d\u00e9gats \u00e0 lui appliqu\u00e9.","title":"Thread"},{"location":"thread/#les-threads","text":"","title":"Les threads"},{"location":"thread/#description-des-threads","text":"","title":"Description des threads :"},{"location":"thread/#gamemaster","text":"Ce thread permet de g\u00e9rer la fin des niveaux, c\u00e0d que faire lorsque il n'y a plus de mostres ou plus de vie pour le joueur. Le thread est bloqu\u00e9 tant qu'il ne ressoit pas de message par queue_F . Ce thread est le plus important, car sans ses acions, le jeu ne peut pas avancer, il a donc la plus grande priorit\u00e9","title":"GameMaster"},{"location":"thread/#joueur_1","text":"Ce tread g\u00e8re les d\u00e9placements et l'affichage du joueur ainsi que ses tirs. Ce thread est important \u00e0 la fluidit\u00e9 du jeu, il \u00e0 donc la deuxi\u00e8me plus grande priorit\u00e9","title":"Joueur_1"},{"location":"thread/#block_enemie","text":"Ce thread g\u00e8re le block d'ennemis, leurs vies, et leurs tirs. Pour chaque pas de temps, chaque monstre \u00e0 une probabilit\u00e9 de tirer de \\(\\frac{\\text{num\u00e9ro de la vague}}{15}\\) . Ainsi, \u00e0 chaque vague le jeu deviens plus dur. Ce thread a une priorit\u00e9 normale.","title":"Block_Enemie"},{"location":"thread/#projectile","text":"Ce thread g\u00e8re les missiles. Il recois les demandes les nouveaux missiles par la queue_N , et si il n'y a pas trop de missiles d\u00e9j\u00e0 en jeu (moins de \\(200\\) ), il le rajoute et commence \u00e0 le simuler. C'est ce thread qui g\u00e8re toutes les collisions. En cas de collisions d\u00e9tecter, il tue le missile incrimin\u00e9 et envoie un messega via la queue_J quand le choc est avec le joueur, et la queue_E lorsque le choc implique un monstre. Ce thread a une priorit\u00e9 normale.","title":"Projectile"},{"location":"thread/#hud","text":"Ce thread g\u00e8re l'affichage de la bar d'info en haut de l'\u00e9cran, il ne fait que lire des varriables partag\u00e9. Ce thread a une priorit\u00e9 basse.","title":"HUD"},{"location":"thread/#chargeur","text":"Ce thread sert a incr\u00e9menter r\u00e9gulierement le compteur representant la charge du tir secondaire. Ce thread a une priorit\u00e9 basse.","title":"chargeur"},{"location":"thread/#communication-entre-les-threads","text":"","title":"Communication entre les threads :"},{"location":"thread/#queue_f","text":"On envoie un objet enum End_Type , cela permet de d\u00e9bloqu\u00e9 le thread GameMaster .","title":"Queue_F"},{"location":"thread/#queue_n","text":"On envoie un objet struct Missile , cela permet de demander la cr\u00e9ation d'un nouveau missile.","title":"Queue_N"},{"location":"thread/#queue_j","text":"On envoie un int8_t qui represente les d\u00e9gats a appliquer au joueur (on peut imaginer des d\u00e9gats n\u00e9gatif pour des soins).","title":"Queue_J"},{"location":"thread/#queue_e","text":"On envoie un objet struct collision qui comporte le num\u00e9ro du monstre et les d\u00e9gats \u00e0 lui appliqu\u00e9.","title":"Queue_E"},{"location":"tuto/","text":"Tutoriel Controls Le vaiseau se d\u00e9place avec le joystick. Pour utilis\u00e9 le tir principale, il faut presser le bouton BP1 (en bas). On dispose d'une seconde attaque, lancant une multitude de missile avec le bouton BP2 (en haut). L'attaque secondaire \u00e0 besoin de se recharger pendant quelque seconde, le tau de charge est mod\u00e9lis\u00e9 par les leds \u00e0 droite de la carte. M\u00e9canique Le but est de d\u00e9truire tous les vaisseaux ennemis. Une fois tous les vaisseaux d\u00e9truit, une nouvelle vague apparait. Chaque vague est plus dur que la pressedante (les ennemis tir plus de projectils). Vous ne pouvez prendre que 5 d\u00e9gats avant la fin de la partie. Fin Le jeu prend fin lorsque vous n'avez plus de vie. Conseils Le tir secondair est tr\u00e8s puissant, il ne faut pas h\u00e9sit\u00e9 \u00e0 l'utiliser. De plus, il faut se consentrer sur l'\u00e9vitement des projectils ennemis.","title":"Tutoriel"},{"location":"tuto/#tutoriel","text":"","title":"Tutoriel"},{"location":"tuto/#controls","text":"Le vaiseau se d\u00e9place avec le joystick. Pour utilis\u00e9 le tir principale, il faut presser le bouton BP1 (en bas). On dispose d'une seconde attaque, lancant une multitude de missile avec le bouton BP2 (en haut). L'attaque secondaire \u00e0 besoin de se recharger pendant quelque seconde, le tau de charge est mod\u00e9lis\u00e9 par les leds \u00e0 droite de la carte.","title":"Controls"},{"location":"tuto/#mecanique","text":"Le but est de d\u00e9truire tous les vaisseaux ennemis. Une fois tous les vaisseaux d\u00e9truit, une nouvelle vague apparait. Chaque vague est plus dur que la pressedante (les ennemis tir plus de projectils). Vous ne pouvez prendre que 5 d\u00e9gats avant la fin de la partie.","title":"M\u00e9canique"},{"location":"tuto/#fin","text":"Le jeu prend fin lorsque vous n'avez plus de vie.","title":"Fin"},{"location":"tuto/#conseils","text":"Le tir secondair est tr\u00e8s puissant, il ne faut pas h\u00e9sit\u00e9 \u00e0 l'utiliser. De plus, il faut se consentrer sur l'\u00e9vitement des projectils ennemis.","title":"Conseils"}]}